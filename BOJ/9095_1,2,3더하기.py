import sys

def recursive(N):
    if N == 1: return 1
    elif N == 2: return 2
    elif N == 3: return 4
    else: 
       return recursive(N - 1) + recursive(N - 2) + recursive(N - 3)

T = int(sys.stdin.readline())

for _ in range(T):
    print(recursive(int(sys.stdin.readline())))

# 점화식을 이용한 풀이
# 문제를 풀기 전에 식의 규칙을 찾기 위해 정수 N이 주어질 때 각각 1, 2, 3으로 만들어지는 방법이 몇 개 있는지 찾아보았다.
# N = 1 -> 1개 / N = 2 -> 2개 / N = 3 -> 4개 / N = 4 -> 7개씩 방법이 나온다.
# 규칙을 식으로 표현하면, f(N) = f(N - 1) + f(N - 2) + f(N - 3)가 된다.
# 이 식을 이용하면 문제를 쉽게 풀 수 있다.
######################################################################################################################

import sys

def DFS(N):
    global cnt

    if N == 0:
        cnt += 1
        return
    
    if N // 3: DFS(N - 3)
    if N // 2: DFS(N - 2)
    if N // 1: DFS(N - 1)

T = int(sys.stdin.readline())

for _ in range(T):
    cnt = 0
    DFS(int(sys.stdin.readline()))
    print(cnt)

# DFS를 이용한 풀이
# 해당 풀이는 DFS를 이용한 풀이로 크래프톤 정글 2기 2주차 같은 조원인 박유빈님의 풀이 방법이다.
# 노가다를 통해 점화식 규칙을 찾아 문제를 풀 수도 있지만, 규칙을 찾기 어려운 문제도 있다.
# N = 4일 떄, DFS함수 매개변수로 4가 들어가서 3과 나누어지는지 검사한다.
# 나누어지기 때문에 함수를 재귀호출하고, 매개변수로 N - 3인 1값을 전달한다. 3을 이용했기 때문에 1, 2, 3중에서 1을 더해야만 4가 되기 때문이다.
# 1은 3과 2로 나누어지지 않고, 1로만 나누어지기 때문에 다시 재귀호출을 통해 0값을 매개변수로 전달한다.
# 0은 어느것으로도 나눌 수 없으며, 함수 처음 부분의 N == 0 조건을 만족하여 카운트 값을 +1해준다.
# 위의 과정을 계속 반복하면 정수 N의 1, 2, 3의 합으로 만들어지는 모든 방법의 수를 구할 수 있다.
######################################################################################################################