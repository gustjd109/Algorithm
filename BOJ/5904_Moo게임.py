import sys

# moogame 함수
# N : 찾고자하는 N번째 글자 / K : 차수 / L : 이전 수열의 길이
def moogame(N, K, L):
    # 새로운 차수의 길이
    # 문제에서 주어진 수열을 바탕으로 구해진 점화식 : len(S[K]) = 2 * len(S[K - 1]) + (K + 3)
    new_L = 2 * L + (K + 3)
    # N값이 3이하면, S[0] 수열에 존재하는 글자이기 때문에 S[0] 수열의 N - 1번째 글자 출력
    # 출력 후, 프로그램 종료
    if N <= 3:
        print(S0[N - 1])
        sys.exit(0)
    # 현재 수열의 길이가 N값보다 작으면, N값이 S[K] 수열의 길이보다 길기 때문에 moogame함수를 재귀호출하여 S[K + 1] 수열을 구한다.
    if new_L < N:
        moogame(N, K + 1, new_L)
    # 현재 수열의 길이가 N값보다 크면, 해당 수열에서 N번째 글자를 출력할 수 있기 때문에 아래 코드를 수행
    else:
        # N값이 이전 수열의 길이보다 크고, 이전 수열의 길이 + 차수 + 3의 값보다 작거나 같으면, -> 중간값 범위에 N값이 있을 때
        if N > L and N <= L + K + 3:
            # 'N값 - 이전 수열의 길이'의 값이 1이 아니라면 'o'를 출력하고, 아니면 'm' 출력
            # 출력 후, 프로그램 종료
            if N - L != 1:
                print('o')
            else:
                print('m')
            sys.exit(0)
        # N값이 중간값 범위보다 초과하면, len(S[K - 1]) 값에서 값을 다시 찾기 위해 moogame함수를 재귀호출
        else:
            moogame(N - (L + K + 3), 1, 3)

if __name__ == "__main__":
    N = int(sys.stdin.readline())
    #S[0]의 수열 초기값 설정
    S0 = ['m', 'o', 'o']
    # moogame함수 호출
    print(moogame(N, 1, 3))

# 이 문제는 수열에 대한 식을 찾아야 풀 수 있는 문제이다.
# 문제의 예제를 통해 찾은 점화식은 len(S[K]) = len(S[K - 1]) + (K + 3) + len(S[K - 1]) -> len(S[K]) = 2 * len(S[K - 1]) + (K + 3)이다.
# 찾은 점화식을 이용하여 재귀함수 호출을 통해 문제를 풀 수 있다.
# N값이 3보다 작으면, 어짜피 S[0] 수열 내에있는 글자이기 때문에 S[0] 수열의 N - 1번째 글자를 출력해준다.
# 현재 수열의 길이가 N값보다 작으면, N값이 S[K] 수열의 길이보다 길기 때문에 함수를 재귀호출하여 S[K + 1] 수열을 구한다.
# 현재 수열의 길이가 N값보다 크면, 해당 수열에서 N번째 글자를 출력할 수 있다.
# N값이 이전 수열의 길이보다 크고, 이전 수열의 길이 + 차수 + 3의 값보다 작거나 같을 때(즉, 중간값 범위에 N값이 있을 때),
# 'N값 - 이전 수열의 길이'의 값이 1이 아니라면 'o'를 출력하고, 아니면 'm' 출력한다.
# N값이 중간값 범위보다 초과하면, len(S[K - 1]) 값에서 값을 다시 찾기 위해 moogame함수를 재귀호출하여 위의 과정을 반복하여 N번째 글자를 찾는다.